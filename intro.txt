Hello to Functional Programming with Haskell, the language which loves Mathematics more than Newton.

This is from the course of University of Pennsylvania

Haskell is a lazy, functional programming language. (lazy means it only calculates or evaluates something when it is actually needed while strict languages evaluates without any need or anything like C or Java )

There is no precise, accepted meaning for the term “functional”. But when we say that Haskell is a functional language, we usually have in mind two things:
- Functions are first-class, that is, functions are values which can be used in exactly the same ways as any other sort of value.
- The meaning of Haskell programs is centered around evaluating expressions rather than executing instructions.


Haskell expressions are always referentially transparent, that is:
- No mutation! Everything (variables, data structures…) is immutable.
- Expressions never have “side effects” (like updating global variables or printing to the screen).
- Calling the same function with the same arguments results in the same output every time.

Haskell is more of a declarative language than of a imperative one. In imperative languages like Python or Java (take an example of a function which gives you the sum), we tell how to calculate the sum and but in declarative, we actually tell what a sum actually is.
A more clearer version to support his statement:

- You describe the steps the computer must follow to get the result — the “how.” This is the imperative style
- example: (python)
def sum_list(lst):
    total = 0
    for x in lst:
        total += x
    return total
Here you explicitly tell the machine:
- Start with total = 0
- Loop over lst
- Add each number to total
- Return total


- You describe the relationship or definition — the “what” — and let the language/runtime figure out the “how.”
-example (haskell):
sumList :: Num a => [a] -> a
sumList xs = foldl (+) 0 xs

- or even shorter, since sum is already defined in Prelude:
sumList :: Num a => [a] -> a
sumList = sum

Here you’re saying:
- "sumList is the sum of all elements in the list."
- No mention of loops, variables, or mutation — the procedure is abstracted away.

- Imperative: You write instructions (like a cooking recipe).
- Declarative: You write the definition or description (like saying “the cake is the sum of these ingredients” without describing each stir).


There are several benefits attached with Haskell:

# Equational Reasoning & Refactoring
- In pure functional languages like Haskell, functions have no side effects — given the same inputs, they always produce the same output.
- This means you can treat an expression just like a mathematical equation.
- “Replace equals by equals” means:
- If you know x = 3 + 4, you can replace x anywhere in your program with 7 without changing behavior.
- If double x = x + x, then double 5 is exactly the same as 5 + 5.
- In imperative languages, this doesn’t always hold because functions can have hidden side effects (e.g., modifying global variables).

code example: (haskell)
square x = x * x
result   = square 4 + square 5

# Parallelism
- Since Haskell expressions don’t depend on mutable shared state, you can evaluate them in parallel without worrying about race conditions.

code (example):
a = slowComputation1
b = slowComputation2
result = a + b

- a and b are independent — Haskell can (and often does) evaluate them at the same time without fear of data corruption.
- In imperative code, if a and b both update shared variables, you’d need locks, synchronization, etc.

# Fewer Headaches
- Side effects and “action at a distance” cause debugging nightmares.
- Action at a distance = when changing one part of your program unexpectedly changes behavior in a completely different part.

- In Haskell, pure functions cannot change global state, so you don’t get these “hidden” interactions. Every change is explicit, and the flow of data is clear.